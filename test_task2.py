import subprocess
import sys
import os
import shutil
import glob

# ==========================================
# CONFIGURATION
# ==========================================
STUDENT_SCRIPT = "task2_pagerank.py"
TEST_INPUT_FILE = "task2_test_graph.txt"
OUTPUT_DIR = "task2_output"

# The example graph from the prompt
TEST_DATA = """0 1
0 2
2 3"""

def create_test_data():
    """Creates the input graph file."""
    with open(TEST_INPUT_FILE, 'w') as f:
        f.write(TEST_DATA)
    print(f"üìÑ Created test input file: {TEST_INPUT_FILE}")

def clean_previous_output():
    """Removes the output directory if it exists."""
    if os.path.exists(OUTPUT_DIR):
        shutil.rmtree(OUTPUT_DIR)
        print(f"üßπ Cleaned up previous output directory: {OUTPUT_DIR}")

def calculate_expected_ranks():
    """
    Simulates the EXACT assignment logic in pure Python to generate
    the expected 'Golden Standard' results.
    """
    print("üßÆ Calculating expected results (Golden Standard)...")
    
    # 1. Parse Graph
    edges = {} # source -> list of destinations
    nodes = set()
    
    for line in TEST_DATA.split('\n'):
        src, dst = line.split()
        nodes.add(src)
        nodes.add(dst)
        if src not in edges: edges[src] = []
        edges[src].append(dst)
        
    sorted_nodes = sorted(list(nodes))
    N = len(nodes)
    
    # 2. Handle Sinks (Assignment Step 0)
    # "Add edge from sink to every other node"
    for node in nodes:
        if node not in edges:
            # It's a sink
            edges[node] = [n for n in nodes if n != node]

    # 3. Initialize Ranks (Assignment Step 1)
    # "Initialize to 1.0"
    ranks = {n: 1.0 for n in nodes}
    
    # 4. Iterations (Assignment Step 4: k=10)
    for _ in range(10):
        contributions = {n: 0.0 for n in nodes}
        
        # Calculate contributions (Step 2)
        for src, dst_list in edges.items():
            num_neighbors = len(dst_list)
            share = ranks[src] / num_neighbors
            for dst in dst_list:
                contributions[dst] += share
        
        # Update Ranks (Step 3)
        # 0.15 + 0.85 * sum_contributions
        new_ranks = {}
        for node in nodes:
            new_ranks[node] = 0.15 + 0.85 * contributions[node]
        ranks = new_ranks

    # 5. Normalization (Assignment Step 5)
    # Divide by Total Vertices
    final_ranks = {n: r / N for n, r in ranks.items()}
    
    return final_ranks

def run_student_script():
    """Runs the student's Spark script."""
    print(f"üöÄ Running {STUDENT_SCRIPT} with pyspark...")
    
    # We assume 'python' maps to an environment where pyspark is installed
    cmd = [sys.executable, STUDENT_SCRIPT, TEST_INPUT_FILE]
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=120 # 2 minute timeout
        )
        return result
    except subprocess.TimeoutExpired:
        print("‚ùå Error: Script timed out.")
        return None
    except Exception as e:
        print(f"‚ùå Error trying to run script: {e}")
        return None

def parse_student_output():
    """Reads the output text file generated by Spark."""
    results = {}
    
    # Spark output is often in part-00000 files inside the directory
    files = glob.glob(os.path.join(OUTPUT_DIR, "part-*"))
    
    if not files:
        print("‚ùå Error: No output part files found in directory.")
        return None

    try:
        for file_path in files:
            with open(file_path, 'r') as f:
                for line in f:
                    parts = line.strip().split()
                    if len(parts) == 2:
                        node = parts[0]
                        rank = float(parts[1])
                        results[node] = rank
        return results
    except Exception as e:
        print(f"‚ùå Error reading output files: {e}")
        return None

def main():
    # Setup
    clean_previous_output()
    create_test_data()
    
    # 1. Get Expected Results
    expected = calculate_expected_ranks()
    
    # 2. Run Student Code
    process_result = run_student_script()
    
    if process_result is None or process_result.returncode != 0:
        print("\n‚ùå Script Execution Failed!")
        if process_result:
            print("--- STDERR ---")
            print(process_result.stderr)
        return

    # 3. Read Student Output
    if not os.path.exists(OUTPUT_DIR):
        print(f"\n‚ùå Output directory '{OUTPUT_DIR}' was not created.")
        return

    student_results = parse_student_output()
    
    if not student_results:
        print("\n‚ùå Could not parse student results.")
        return

    # 4. Compare
    print("\n" + "="*40)
    print("      TASK 2 VALIDATION REPORT")
    print("="*40)
    
    all_passed = True
    
    # Check if all nodes are present
    if len(student_results) != len(expected):
        print(f"‚ùå Node Count Mismatch: Expected {len(expected)}, Got {len(student_results)}")
        all_passed = False
    
    print(f"{'Node':<5} | {'Expected':<10} | {'Actual':<10} | {'Status'}")
    print("-" * 45)
    
    for node in sorted(expected.keys()):
        exp_val = expected[node]
        act_val = student_results.get(node, 0.0)
        
        # Allow small floating point tolerance (e.g., 1e-4)
        is_close = abs(exp_val - act_val) < 0.0001
        status = "‚úÖ PASS" if is_close else "‚ùå FAIL"
        
        if not is_close: all_passed = False
        
        print(f"{node:<5} | {exp_val:.6f}   | {act_val:.6f}   | {status}")

    print("-" * 45)
    
    # 5. Final Checklist Validation
    print("\nChecklist Verification:")
    
    checks = [
        ("Input Handling", os.path.exists(TEST_INPUT_FILE), "PASSED"),
        ("Output Generation", os.path.exists(OUTPUT_DIR), "PASSED"),
        ("Sink Node Logic", all_passed, "PASSED" if all_passed else "FAILED (Numbers do not match specific sink logic)"),
        ("Late Normalization", all_passed, "PASSED" if all_passed else "FAILED (Check normalization step)")
    ]
    
    for name, condition, status in checks:
        icon = "[x]" if condition else "[ ]"
        print(f"{icon} {name:<20}: {status}")

    if all_passed:
        print("\nüéâ SUCCESS: Code meets all Task 2 requirements!")
    else:
        print("\n‚ö†Ô∏è FAILURE: Results do not match assignment requirements.")

if __name__ == "__main__":
    main()